/*
 * Timer_Program.c
 *
 *  Created on: Jul 14, 2023
 *      Author: Lenovo
 */
#include "STD_TYPES.h"
#include "BIT_MATH.h"
#define F_CPU     8000000UL
#include <util/delay.h>
#include "Timer_Config.h"
#include "Timer_Interface.h"
#include "Timer_Private.h"
#include "Timer_Register.h"


static void(*TMRS_pfTimer0OVF)(void)= NULL ;
static void(*TMRS_pfTimer0CTC)(void)= NULL ;

static void(*TMRS_pfTimer1)(void)= NULL ;
static void(*TMRS_pfTimer1CTCA)(void)= NULL ;
static void(*TMRS_pfTimer1CTCB)(void)= NULL ;

void TMRS_voidTMR0Init(void){

#if TMR_MODE0 == NORMAL

	CLR_BIT(TCCR0,TCCR0_WGM00);
	CLR_BIT(TCCR0,TCCR0_WGM01);

	TCNT0=PRELOAD_VALUE0;

	SET_BIT(TIMSK,TIMSK_TOIE0);


#elif TMR_MODE0 == PWM_PHASE

#if TMR_ACTION0 == NORMAL_1

	CLR_BIT(TCCR0,TCCR0_COM01);
	CLR_BIT(TCCR0,TCCR0_COM00);

#elif TMR_ACTION0 == NON_INVERTING

	SET_BIT(TCCR0,TCCR0_COM01);
	CLR_BIT(TCCR0,TCCR0_COM00);

#elif TMR_ACTION0 == INVERTING
	SET_BIT(TCCR0,TCCR0_COM01);
	SET_BIT(TCCR0,TCCR0_COM00);

#endif


	SET_BIT(TCCR0,TCCR0_WGM00);
	CLR_BIT(TCCR0,TCCR0_WGM01);



#elif TMR_MODE0 == CTC

#if TMR_ACTION0 == NORMAL_1

	CLR_BIT(TCCR0,TCCR0_COM01);
	CLR_BIT(TCCR0,TCCR0_COM00);

#elif TMR_ACTION0 == TOGGLE
	CLR_BIT(TCCR0,TCCR0_COM01);
	SET_BIT(TCCR0,TCCR0_COM00);

#elif TMR_ACTION0 == CLEAR

	SET_BIT(TCCR0,TCCR0_COM01);
	CLR_BIT(TCCR0,TCCR0_COM00);

#elif TMR_ACTION0 == SET
	SET_BIT(TCCR0,TCCR0_COM01);
	SET_BIT(TCCR0,TCCR0_COM00);

#endif

	CLR_BIT(TCCR0,TCCR0_WGM00);
	SET_BIT(TCCR0,TCCR0_WGM01);

	SET_BIT(TIMSK,TIMSK_OCIE0);

#elif TMR_MODE0 == FAST_PWM

#if TMR_ACTION0 == NORMAL_1

	CLR_BIT(TCCR0,TCCR0_COM01);
	CLR_BIT(TCCR0,TCCR0_COM00);

#elif TMR_ACTION0 == NON_INVERTING

	SET_BIT(TCCR0,TCCR0_COM01);
	CLR_BIT(TCCR0,TCCR0_COM00);

#elif TMR_ACTION0 == INVERTING
	SET_BIT(TCCR0,TCCR0_COM01);
	SET_BIT(TCCR0,TCCR0_COM00);

#endif

	SET_BIT(TCCR0,TCCR0_WGM00);
	SET_BIT(TCCR0,TCCR0_WGM01);

#endif

#if CLK_PreScalar0 == NO_CLK_SOURCE

	CLR_BIT(TCCR0,TCCR0_CS02);
	CLR_BIT(TCCR0,TCCR0_CS01);
	CLR_BIT(TCCR0,TCCR0_CS00);

#elif CLK_PreScalar0 == NO_DIV

	CLR_BIT(TCCR0,TCCR0_CS02);
	CLR_BIT(TCCR0,TCCR0_CS01);
	SET_BIT(TCCR0,TCCR0_CS00);


#elif CLK_PreScalar0 == DIV_BY_8

	CLR_BIT(TCCR0,TCCR0_CS02);
	SET_BIT(TCCR0,TCCR0_CS01);
	CLR_BIT(TCCR0,TCCR0_CS00);

#elif CLK_PreScalar0 == DIV_BY_64

	CLR_BIT(TCCR0,TCCR0_CS02);
	SET_BIT(TCCR0,TCCR0_CS01);
	SET_BIT(TCCR0,TCCR0_CS00);


#elif CLK_PreScalar0 == DIV_BY_256

	SET_BIT(TCCR0,TCCR0_CS02);
	CLR_BIT(TCCR0,TCCR0_CS01);
	CLR_BIT(TCCR0,TCCR0_CS00);

#elif CLK_PreScalar0 == DIV_BY_1024

	SET_BIT(TCCR0,TCCR0_CS02);
	CLR_BIT(TCCR0,TCCR0_CS01);
	SET_BIT(TCCR0,TCCR0_CS00);

#elif CLK_PreScalar0 == COUNTER_FALL

	SET_BIT(TCCR0,TCCR0_CS02);
	SET_BIT(TCCR0,TCCR0_CS01);
	CLR_BIT(TCCR0,TCCR0_CS00);

#elif CLK_PreScalar0 == COUNTER_RISE

	SET_BIT(TCCR0,TCCR0_CS02);
	SET_BIT(TCCR0,TCCR0_CS01);
	SET_BIT(TCCR0,TCCR0_CS00);

#endif



}



void TMRS_voidTimer0SetCompareMatchValue(u8 Copy_u8_Value){

	OCR0=Copy_u8_Value;
}

void TMRS_voidTimer0SetCallBack(void (*Copy_pf) (void)){

	if (Copy_pf != NULL ){
		TMRS_pfTimer0OVF=Copy_pf;
	}

}


#if TMR_MODE0 == NORMAL

void __vector_11(void) __attribute__((signal));

void __vector_11(void) {

	if (TMRS_pfTimer0OVF != NULL){
		TMRS_pfTimer0OVF();
	}
}



/*void __vector_11(void) __attribute__((signal));

void __vector_11(void) {




static u16 Local_u16CounterTMR0_OVF = 0;
Local_u16CounterTMR0_OVF++ ;

if( Local_u16CounterTMR0_OVF == 19532 )          // INCASE OF 5 SECONDS   EQUALS 19531.25  PRELOAD VALUE == 192
{
                                                 // INCASE 1 SECONDS EQUALS 3906.25     PRELOAD VALUE == 192
	TMRS_u8_TCNT0_REG=PRELOAD_VALUE;
	Local_u16CounterTMR0_OVF = 0;
	TMRS_pfTimer0OVF();
}
} */


#elif TMR_MODE0 == CTC

void __vector_10(void) __attribute__((signal));

void __vector_10(void)

if (TMRS_pfTimer0OVF != NULL){
	TMRS_pfTimer0OVF();
}
}


/*{

static u16 Local_u16CounterTMR0_CTC = 0;
Local_u16CounterTMR0_CTC++ ;


if( Local_u16CounterTMR0_CTC == 10000 )    // 10 000 CTC Interrupts is 100*(1us) * 10k = 1s   OSCR 100              COMP MATCH COUNT=1*10^(6)/100 == 10000
{
	Local_u16CounterTMR0_CTC = 0;
	TMRS_pfTimer0OVF();
}
}
*/
#endif



void TMRS_voidTMR1Init(void){

#if TMR_MODE1 == MODE_0

	CLR_BIT(TCCR1A,TCCR1A_WGM10);
	CLR_BIT(TCCR1A,TCCR1A_WGM11);
	CLR_BIT(TCCR1B,TCCR1B_WGM12);
	CLR_BIT(TCCR1B,TCCR1B_WGM13);

	SET_BIT(TIMSK,TIMSK_TOIE1);

#elif TMR_MODE1 == MODE_1

	SET_BIT(TCCR1A,TCCR1A_WGM10);
	CLR_BIT(TCCR1A,TCCR1A_WGM11);
	CLR_BIT(TCCR1B,TCCR1B_WGM12);
	CLR_BIT(TCCR1B,TCCR1B_WGM13);

#elif TMR_MODE1 == MODE_2

	CLR_BIT(TCCR1A,TCCR1A_WGM10);
	SET_BIT(TCCR1A,TCCR1A_WGM11);
	CLR_BIT(TCCR1B,TCCR1B_WGM12);
	CLR_BIT(TCCR1B,TCCR1B_WGM13);

#elif TMR_MODE1 == MODE_3

	SET_BIT(TCCR1A,TCCR1A_WGM10);
	SET_BIT(TCCR1A,TCCR1A_WGM11);
	CLR_BIT(TCCR1B,TCCR1B_WGM12);
	CLR_BIT(TCCR1B,TCCR1B_WGM13);

#elif TMR_MODE1 == MODE_4

	CLR_BIT(TCCR1A,TCCR1A_WGM10);
	CLR_BIT(TCCR1A,TCCR1A_WGM11);
	SET_BIT(TCCR1B,TCCR1B_WGM12);
	CLR_BIT(TCCR1B,TCCR1B_WGM13);


#elif TMR_MODE1 == MODE_5

	SET_BIT(TCCR1A,TCCR1A_WGM10);
	CLR_BIT(TCCR1A,TCCR1A_WGM11);
	SET_BIT(TCCR1B,TCCR1B_WGM12);
	CLR_BIT(TCCR1B,TCCR1B_WGM13);

#elif TMR_MODE1 == MODE_6

	CLR_BIT(TCCR1A,TCCR1A_WGM10);
	SET_BIT(TCCR1A,TCCR1A_WGM11);
	SET_BIT(TCCR1B,TCCR1B_WGM12);
	CLR_BIT(TCCR1B,TCCR1B_WGM13);

#elif TMR_MODE1 == MODE_7

	SET_BIT(TCCR1A,TCCR1A_WGM10);
	SET_BIT(TCCR1A,TCCR1A_WGM11);
	SET_BIT(TCCR1B,TCCR1B_WGM12);
	CLR_BIT(TCCR1B,TCCR1B_WGM13);

#elif TMR_MODE1 == MODE_8

	CLR_BIT(TCCR1A,TCCR1A_WGM10);
	CLR_BIT(TCCR1A,TCCR1A_WGM11);
	CLR_BIT(TCCR1B,TCCR1B_WGM12);
	SET_BIT(TCCR1B,TCCR1B_WGM13);

#elif TMR_MODE1 == MODE_9

	SET_BIT(TCCR1A,TCCR1A_WGM10);
	CLR_BIT(TCCR1A,TCCR1A_WGM11);
	CLR_BIT(TCCR1B,TCCR1B_WGM12);
	SET_BIT(TCCR1B,TCCR1B_WGM13);


#elif TMR_MODE1 == MODE_10

	CLR_BIT(TCCR1A,TCCR1A_WGM10);
	SET_BIT(TCCR1A,TCCR1A_WGM11);
	CLR_BIT(TCCR1B,TCCR1B_WGM12);
	SET_BIT(TCCR1B,TCCR1B_WGM13);

#elif TMR_MODE1 == MODE_11

	SET_BIT(TCCR1A,TCCR1A_WGM10);
	SET_BIT(TCCR1A,TCCR1A_WGM11);
	CLR_BIT(TCCR1B,TCCR1B_WGM12);
	SET_BIT(TCCR1B,TCCR1B_WGM13);


#elif TMR_MODE1 == MODE_12

	CLR_BIT(TCCR1A,TCCR1A_WGM10);
	CLR_BIT(TCCR1A,TCCR1A_WGM11);
	SET_BIT(TCCR1B,TCCR1B_WGM12);
	SET_BIT(TCCR1B,TCCR1B_WGM13);


#elif TMR_MODE1 == MODE_13

	SET_BIT(TCCR1A,TCCR1A_WGM10);
	CLR_BIT(TCCR1A,TCCR1A_WGM11);
	SET_BIT(TCCR1B,TCCR1B_WGM12);
	SET_BIT(TCCR1B,TCCR1B_WGM13);

#elif TMR_MODE1 == MODE_14

	CLR_BIT(TCCR1A,TCCR1A_WGM10);
	SET_BIT(TCCR1A,TCCR1A_WGM11);
	SET_BIT(TCCR1B,TCCR1B_WGM12);
	SET_BIT(TCCR1B,TCCR1B_WGM13);

#elif TMR_MODE1 == MODE_15

	SET_BIT(TCCR1A,TCCR1A_WGM10);
	SET_BIT(TCCR1A,TCCR1A_WGM11);
	SET_BIT(TCCR1B,TCCR1B_WGM12);
	SET_BIT(TCCR1B,TCCR1B_WGM13);



#endif

#if CHANNEL == A

#if TMR_ACTION1 == NORMAL

	CLR_BIT(TCCR1A,TCCR1A_COMA0);
	CLR_BIT(TCCR1A,TCCR1A_COMA1);

#elif TMR_ACTION1 == TOGGLE

	SET_BIT(TCCR1A,TCCR1A_COMA0);
	CLR_BIT(TCCR1A,TCCR1A_COMA1);

	SET_BIT(TIMSK,TIMSK_OCIE1A);

#elif TMR_ACTION1 == CLEAR

	CLR_BIT(TCCR1A,TCCR1A_COMA0);
	SET_BIT(TCCR1A,TCCR1A_COMA1);

	SET_BIT(TIMSK,TIMSK_OCIE1A);


#elif TMR_ACTION1 == SET

	SET_BIT(TCCR1A,TCCR1A_COMA0);
	SET_BIT(TCCR1A,TCCR1A_COMA1);

	SET_BIT(TIMSK,TIMSK_OCIE1A);

#elif TMR_ACTION1 == INVERTING

	SET_BIT(TCCR1A,TCCR1A_COMA0);
	SET_BIT(TCCR1A,TCCR1A_COMA1);

#elif TMR_ACTION1 == NON_INVERTING

	CLR_BIT(TCCR1A,TCCR1A_COMA0);
	SET_BIT(TCCR1A,TCCR1A_COMA1);


#endif

#elif CHANNEL == B

#if TMR_ACTION1 == NORMAL
	CLR_BIT(TCCR1A,TCCR1A_COMB0);
	CLR_BIT(TCCR1A,TCCR1A_COMB1);

#elif TMR_ACTION1 == TOGGLE

	SET_BIT(TCCR1A,TCCR1A_COMB0);
	CLR_BIT(TCCR1A,TCCR1A_COMB1);

	SET_BIT(TIMSK,TIMSK_OCIE1B);

#elif TMR_ACTION1 == CLEAR

	CLR_BIT(TCCR1A,TCCR1A_COMB0);
	SET_BIT(TCCR1A,TCCR1A_COMB1);

	SET_BIT(TIMSK,TIMSK_OCIE1B);

#elif TMR_ACTION1 == SET

	SET_BIT(TCCR1A,TCCR1A_COMB0);
	SET_BIT(TCCR1A,TCCR1A_COMB1);

	SET_BIT(TIMSK,TIMSK_OCIE1B);

#elif TMR_ACTION1 == INVERTING

	SET_BIT(TCCR1A,TCCR1A_COMB0);
	SET_BIT(TCCR1A,TCCR1A_COMB1);

#elif TMR_ACTION1 == NON_INVERTING

	CLR_BIT(TCCR1A,TCCR1A_COMB0);
	SET_BIT(TCCR1A,TCCR1A_COMB1);

#endif
#endif


#if CLK_PreScalar1 == NO_CLK_SOURCE

	CLR_BIT(TCCR1B,TCCR0_CS02);
	CLR_BIT(TCCR1B,TCCR0_CS01);
	CLR_BIT(TCCR1B,TCCR0_CS00);

#elif CLK_PreScalar1 == NO_DIV

	CLR_BIT(TCCR1B,TCCR0_CS02);
	CLR_BIT(TCCR1B,TCCR0_CS01);
	SET_BIT(TCCR1B,TCCR0_CS00);


#elif CLK_PreScalar1 == DIV_BY_8

	CLR_BIT(TCCR1B,TCCR0_CS02);
	SET_BIT(TCCR1B,TCCR0_CS01);
	CLR_BIT(TCCR1B,TCCR0_CS00);

#elif CLK_PreScalar1 == DIV_BY_64

	CLR_BIT(TCCR1B,TCCR0_CS02);
	SET_BIT(TCCR1B,TCCR0_CS01);
	SET_BIT(TCCR1B,TCCR0_CS00);


#elif CLK_PreScalar1 == DIV_BY_256

	SET_BIT(TCCR1B,TCCR0_CS02);
	CLR_BIT(TCCR1B,TCCR0_CS01);
	CLR_BIT(TCCR1B,TCCR0_CS00);

#elif CLK_PreScalar1 == DIV_BY_1024

	SET_BIT(TCCR1B,TCCR0_CS02);
	CLR_BIT(TCCR1B,TCCR0_CS01);
	SET_BIT(TCCR1B,TCCR0_CS00);

#elif CLK_PreScalar1 == COUNTER_FALL

	SET_BIT(TCCR1B,TCCR0_CS02);
	SET_BIT(TCCR1B,TCCR0_CS01);
	CLR_BIT(TCCR1B,TCCR0_CS00);

#elif CLK_PreScalar1 == COUNTER_RISE

	SET_BIT(TCCR1B,TCCR0_CS02);
	SET_BIT(TCCR1B,TCCR0_CS01);
	SET_BIT(TCCR1B,TCCR0_CS00);

#endif







}

void TMRS_voidTimer1SetCompareMatchValue(u16 Copy_u8OCR1Value) {
#if CHANNEL == A
	OCR1A = Copy_u8OCR1Value;
#elif CHANNEL == B
	OCR1B = Copy_u8OCR1Value;
#endif
}

void TMRS_voidTimer1SetOverflowValue(u16 Copy_u8ICR1Value) {

	ICR1 = Copy_u8ICR1Value ;


}


void TMRS_voidTimer1SetCallBack(void (*Copy_pf) (void)){

	if (Copy_pf != NULL ){
		TMRS_pfTimer1=Copy_pf;
	}

}


#if TMR_MODE1 == MODE_4  && CHANNEL == A

void __vector_7(void) __attribute__((signal));

void __vector_7(void) {

	if (TMRS_pfTimer1 != NULL){
		TMRS_pfTimer1();
	}
}

#elif TMR_MODE1 == MODE_4  && CHANNEL == B

void __vector_8(void) __attribute__((signal));

void __vector_8(void) {

	if (TMRS_pfTimer1 != NULL){
		TMRS_pfTimer1();
	}
}

#elif TMR_MODE1 == MODE_12  && CHANNEL == A

void __vector_7(void) __attribute__((signal));

void __vector_7(void) {

	if (TMRS_pfTimer1 != NULL){
		TMRS_pfTimer1();
	}
}

#elif TMR_MODE1 == MODE_12  && CHANNEL == B

void __vector_8(void) __attribute__((signal));

void __vector_8(void) {

	if (TMRS_pfTimer1 != NULL){
		TMRS_pfTimer1();
	}
}

#elif TMR_MODE1 == MODE_0

void __vector_9(void) __attribute__((signal));

void __vector_9(void) {

	if (TMRS_pfTimer1 != NULL){
		TMRS_pfTimer1();
	}
}

#endif

void ServoSwing (u8 Copy_u8ServoAngle) {

     switch(Copy_u8ServoAngle) {

     case 0:

	OCR1A = 999;
     _delay_ms(500);  break;

     case 90:

	OCR1A = 1499;
     _delay_ms(500); break;

     case 180:

	OCR1A = 1999;
     _delay_ms(500); break;

     default: break;

     }


}

